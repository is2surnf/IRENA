// frontend/src/hooks/useSimulacion.ts 
import { useState, useCallback, useRef, useEffect } from 'react';
import { v4 as uuidv4 } from 'uuid';
import type { 
  EstadoSimulacion, 
  ObjetoSimulacion, 
  Utensilio, 
  Elemento, 
  Reaccion,
  EfectosReaccion,
  ContenidoUtensilio,
  ReaccionDetectadaResponse
} from '../types/simulacion.types';
import { reaccionesService } from '../services/reacciones.service';
// CORRECCI√ìN 3: Importar THREE para que calcularColorMezcla funcione
import * as THREE from 'three'; 

const initialState: EstadoSimulacion = {
  activa: false,
  objetosEnMesa: [],
  temperatura: 25,
  pH: 7.0,
  tiempo: 0,
  resultados: [],
  historialReacciones: [],
  advertencias: []
};

export const useSimulacion = () => {
  const [estado, setEstado] = useState<EstadoSimulacion>(initialState);
  const [efectosActivos, setEfectosActivos] = useState<EfectosReaccion | null>(null);
  const [reaccionEnProgreso, setReaccionEnProgreso] = useState<string | null>(null);
  // CORRECCI√ìN 1: Cambiar NodeJS.Timeout a number para entorno de navegador
  const tiempoRef = useRef<number | null>(null);

  // ============================================
  // GESTI√ìN DE ESTADO MEJORADA
  // ============================================

  const agregarUtensilio = useCallback((utensilio: Utensilio, position: [number, number, number] = [0, 0.1, 0]): string => {
    const nuevoObjeto: ObjetoSimulacion = {
      id: uuidv4(),
      tipo: 'utensilio',
      data: utensilio,
      position,
      rotation: [0, 0, 0],
      contenido: {
        elementos: [],
        nivel: 0,
        color: '#FFFFFF',
        temperatura: 25,
        estado: 'reposo'
      }
    };

    setEstado(prev => ({
      ...prev,
      objetosEnMesa: [...prev.objetosEnMesa, nuevoObjeto],
      advertencias: [...(prev.advertencias || []), `‚úÖ ${utensilio.nombre} agregado a la mesa`]
    }));

    return nuevoObjeto.id;
  }, []);

  const agregarElementoAUtensilio = useCallback((utensilioId: string, elemento: Elemento) => {
    setEstado(prev => {
      const utensilio = prev.objetosEnMesa.find(obj => obj.id === utensilioId && obj.tipo === 'utensilio');
      
      if (!utensilio || !utensilio.contenido) {
        console.warn('Utensilio no encontrado o sin contenido');
        return prev;
      }

      const nuevosObjetos = prev.objetosEnMesa.map(objeto => {
        if (objeto.id === utensilioId && objeto.tipo === 'utensilio' && objeto.contenido) {
          const elementosExistentes = objeto.contenido.elementos;
          
          // Verificar si el elemento ya existe
          const elementoExistente = elementosExistentes.find(e => e.id === elemento.id);
          if (elementoExistente) {
            return objeto; // No agregar duplicados
          }

          const nuevoContenido: ContenidoUtensilio = {
            ...objeto.contenido,
            elementos: [...elementosExistentes, elemento],
            nivel: Math.min(1, objeto.contenido.nivel + 0.25),
            color: calcularColorMezcla([...elementosExistentes, elemento]),
            temperatura: objeto.contenido.temperatura + (elemento.categoria === '√Åcidos' ? 5 : 0),
            estado: elementosExistentes.length > 0 ? 'mezclando' : 'reposo'
          };
          
          return {
            ...objeto,
            contenido: nuevoContenido
          };
        }
        return objeto;
      });

      const mensaje = `‚ûï ${elemento.nombre} (${elemento.simbolo}) agregado al utensilio`;
      
      return {
        ...prev,
        objetosEnMesa: nuevosObjetos,
        resultados: [...prev.resultados, mensaje],
        advertencias: [...(prev.advertencias || []), mensaje]
      };
    });
  }, []);

  // ============================================
  // DETECCI√ìN DE REACCIONES MEJORADA
  // ============================================

  const detectarReaccion = useCallback(async (utensilioId: string): Promise<Reaccion | null> => {
    const utensilio = estado.objetosEnMesa.find(obj => obj.id === utensilioId);
    
    if (!utensilio || !utensilio.contenido || utensilio.contenido.elementos.length < 2) {
      console.log('No hay suficientes elementos para detectar reacci√≥n');
      return null;
    }

    // Verificar si ya hay una reacci√≥n en progreso
    if (reaccionEnProgreso === utensilioId) {
      console.log('Reacci√≥n ya en progreso para este utensilio');
      return null;
    }

    const simbolosElementos = utensilio.contenido.elementos.map(e => e.simbolo || '');
    
    try {
      console.log('üî¨ Detectando reacci√≥n para elementos:', simbolosElementos);
      
      const response: ReaccionDetectadaResponse = await reaccionesService.detectarReaccion({
        utensilio_id: utensilioId,
        elementos: simbolosElementos.filter(s => s)
      });

      if (response.reaccion) {
        console.log('üéâ Reacci√≥n detectada:', response.reaccion.nombre);
        
        setReaccionEnProgreso(utensilioId);
        setEstado(prev => ({
          ...prev,
          // CORRECCI√ìN 2: Usar ! para asegurar el tipo, resolviendo Error 2345
          reaccionActual: response.reaccion!,
          // CORRECCI√ìN 2: Usar ! para asegurar el tipo, resolviendo Error 18047
          resultados: [...prev.resultados, `‚ö° Reacci√≥n iniciada: ${response.reaccion!.nombre}`], 
          // CORRECCI√ìN 2: Usar ! para asegurar el tipo, resolviendo Error 18047
          advertencias: [...(prev.advertencias || []), `üî• ${response.reaccion!.nombre} detectada!`] 
        }));
        
        // Activar efectos visuales
        setEfectosActivos(response.reaccion.efectos);
        
        // Actualizar estado del utensilio
        setEstado(prev => ({
          ...prev,
          objetosEnMesa: prev.objetosEnMesa.map(obj => 
            obj.id === utensilioId && obj.tipo === 'utensilio' && obj.contenido
              ? {
                  ...obj,
                  contenido: {
                    ...obj.contenido,
                    estado: 'reaccionando',
                    temperatura: response.reaccion!.efectos.temperatura,
                    color: response.reaccion!.efectos.colorFinal
                  }
                }
              : obj
          )
        }));

        // Programar finalizaci√≥n de la reacci√≥n
        const duracion = (response.reaccion.efectos.duracion || 8) * 1000;
        
        setTimeout(() => {
          console.log('‚úÖ Reacci√≥n completada');
          setReaccionEnProgreso(null);
          setEfectosActivos(null);
          
          setEstado(prev => ({
            ...prev,
            reaccionActual: undefined,
            // CORRECCI√ìN 2: Usar ! para asegurar el tipo en el closure (Error 18047)
            historialReacciones: [...(prev.historialReacciones || []), response.reaccion!], 
            objetosEnMesa: prev.objetosEnMesa.map(obj => 
              obj.id === utensilioId && obj.tipo === 'utensilio' && obj.contenido
                ? {
                    ...obj,
                    contenido: {
                      ...obj.contenido,
                      estado: 'completado',
                      temperatura: 25
                    }
                  }
                : obj
            ),
            // CORRECCI√ìN 2: Usar ! para asegurar el tipo en el closure (Error 18047)
            advertencias: [...(prev.advertencias || []), `‚úÖ ${response.reaccion!.nombre} completada`] 
          }));
        }, duracion);
        
        return response.reaccion;
      } else {
        console.log('‚ùå No se detect√≥ reacci√≥n para:', simbolosElementos);
        setEstado(prev => ({
          ...prev,
          advertencias: [...(prev.advertencias || []), `‚ùå No se detect√≥ reacci√≥n para la combinaci√≥n`]
        }));
        return null;
      }
    } catch (error) {
      console.error('üö® Error detectando reacci√≥n:', error);
      
      // Fallback a detecci√≥n local
      const reaccionLocal = detectarReaccionLocal(utensilio.contenido.elementos);
      if (reaccionLocal) {
        console.log('üîÑ Usando reacci√≥n local de fallback:', reaccionLocal.nombre);
        return reaccionLocal;
      }
      
      setEstado(prev => ({
        ...prev,
        advertencias: [...(prev.advertencias || []), `‚ö†Ô∏è Error de conexi√≥n. Reintentando...`]
      }));
      
      return null;
    }
  }, [estado.objetosEnMesa, reaccionEnProgreso]);

  // ============================================
  // DETECCI√ìN LOCAL DE REACCIONES (FALLBACK)
  // ============================================

  const detectarReaccionLocal = useCallback((elementos: Elemento[]): Reaccion | null => {
    const simbolos = elementos.map(e => e.simbolo).sort();
    const reaccionesLocales = obtenerReaccionesLocales();

    // Buscar reacci√≥n exacta
    for (const reaccion of reaccionesLocales) {
      const reactivosReaccion = [...reaccion.reactivos].sort();
      
      if (JSON.stringify(simbolos) === JSON.stringify(reactivosReaccion)) {
        return reaccion;
      }
    }

    // Buscar reacci√≥n parcial (al menos 2 elementos coinciden)
    for (const reaccion of reaccionesLocales) {
      const reactivosReaccion = [...reaccion.reactivos];
      const elementosCoincidentes = simbolos.filter(s => reactivosReaccion.includes(s));
      
      if (elementosCoincidentes.length >= 2) {
        console.log('üîç Reacci√≥n parcial detectada:', reaccion.nombre);
        return {
          ...reaccion,
          nombre: `${reaccion.nombre} (Parcial)`,
          efectos: {
            ...reaccion.efectos,
            intensidadLuz: reaccion.efectos.intensidadLuz ? reaccion.efectos.intensidadLuz * 0.7 : 0.5
          }
        };
      }
    }

    return null;
  }, []);

  // ============================================
  // GESTI√ìN DE SIMULACI√ìN MEJORADA
  // ============================================

  const iniciarReaccion = useCallback(async (utensilioId: string) => {
    if (reaccionEnProgreso) {
      console.log('‚è≥ Ya hay una reacci√≥n en progreso');
      return;
    }

    console.log('üöÄ Iniciando reacci√≥n manual para utensilio:', utensilioId);
    const reaccion = await detectarReaccion(utensilioId);
    
    if (reaccion) {
      setEstado(prev => ({
        ...prev,
        // CORRECCI√ìN 2: Usar ! para asegurar el tipo (Error 18047)
        resultados: [...prev.resultados, `üéØ Reacci√≥n manual iniciada: ${reaccion!.nombre}`],
        advertencias: [...(prev.advertencias || []), `‚ö° Reacci√≥n manual activada!`]
      }));
    }
  }, [detectarReaccion, reaccionEnProgreso]);

  const iniciarSimulacion = useCallback(() => {
    if (estado.activa) {
      console.log('‚è∏Ô∏è La simulaci√≥n ya est√° activa');
      return;
    }

    console.log('üî¨ Iniciando simulaci√≥n de laboratorio');
    setEstado(prev => ({
      ...prev,
      activa: true,
      tiempo: 0,
      resultados: [...prev.resultados, 'üî¨ Simulaci√≥n de laboratorio iniciada'],
      advertencias: [...(prev.advertencias || []), 'üéØ Modo experimental activado']
    }));

    // Sistema de tiempo mejorado
    if (tiempoRef.current) {
      clearInterval(tiempoRef.current);
    }

    tiempoRef.current = setInterval(() => {
      setEstado(prev => ({
        ...prev,
        tiempo: prev.tiempo + 1,
        temperatura: prev.temperatura + (Math.random() - 0.5) * 0.1, // Fluctuaci√≥n natural
        pH: Math.max(0, Math.min(14, prev.pH + (Math.random() - 0.5) * 0.05)) // Fluctuaci√≥n controlada
      }));
    }, 1000);
  }, [estado.activa]);

  const detenerSimulacion = useCallback(() => {
    console.log('‚èπÔ∏è Deteniendo simulaci√≥n');
    
    if (tiempoRef.current) {
      clearInterval(tiempoRef.current);
      tiempoRef.current = null;
    }

    setEstado(prev => ({
      ...prev,
      activa: false,
      resultados: [...prev.resultados, '‚èπÔ∏è Simulaci√≥n detenida'],
      advertencias: [...(prev.advertencias || []), 'üí§ Modo experimental pausado']
    }));
  }, []);

  const limpiarMesa = useCallback(() => {
    console.log('üßπ Limpiando mesa de laboratorio');
    
    if (tiempoRef.current) {
      clearInterval(tiempoRef.current);
      tiempoRef.current = null;
    }

    setEstado(initialState);
    setEfectosActivos(null);
    setReaccionEnProgreso(null);
  }, []);

  // ============================================
  // MANIPULACI√ìN DE OBJETOS MEJORADA
  // ============================================

  const moverObjeto = useCallback((id: string, newPosition: [number, number, number]) => {
    setEstado(prev => ({
      ...prev,
      objetosEnMesa: prev.objetosEnMesa.map(obj =>
        obj.id === id ? { ...obj, position: newPosition } : obj
      )
    }));
  }, []);

  const eliminarObjeto = useCallback((id: string) => {
    const objeto = estado.objetosEnMesa.find(obj => obj.id === id);
    
    setEstado(prev => ({
      ...prev,
      objetosEnMesa: prev.objetosEnMesa.filter(obj => obj.id !== id),
      advertencias: [
        ...(prev.advertencias || []), 
        `üóëÔ∏è ${objeto?.tipo === 'utensilio' ? (objeto.data as Utensilio).nombre : 'Elemento'} removido`
      ]
    }));
  }, [estado.objetosEnMesa]);

  const reiniciarExperimento = useCallback(() => {
    console.log('üîÑ Reiniciando experimento');
    
    setEstado(prev => ({
      ...initialState,
      historialReacciones: prev.historialReacciones // Mantener historial
    }));
    
    setEfectosActivos(null);
    setReaccionEnProgreso(null);
  }, []);

  // ============================================
  // EFECTOS DE LIMPIEZA
  // ============================================

  useEffect(() => {
    return () => {
      if (tiempoRef.current) {
        clearInterval(tiempoRef.current);
      }
    };
  }, []);

  // ============================================
  // FUNCIONES AUXILIARES
  // ============================================

  function calcularColorMezcla(elementos: Elemento[]): string {
    if (elementos.length === 0) return '#FFFFFF';
    
    const coloresCategoria = {
      'Metales': '#FFD700',
      'No metales': '#4A90E2',
      'Gases y Hal√≥genos': '#9B59B6',
      '√Åcidos': '#E74C3C',
      'Bases': '#27AE60',
      'Sales': '#ECF0F1'
    };

    const colores = elementos.map(e => coloresCategoria[e.categoria] || '#4A90E2');
    
    // Mezcla simple de colores
    if (colores.length === 1) return colores[0];
    
    // Para m√∫ltiples elementos, crear un gradiente
    const colorBase = colores[0];
    const variacion = elementos.length * 40;
    
    const color = new THREE.Color(colorBase);
    const hsl = { h: 0, s: 0, l: 0 };
    color.getHSL(hsl);
    
    hsl.h = (hsl.h + (variacion / 360)) % 1;
    hsl.s = Math.min(1, hsl.s * 1.2);
    
    color.setHSL(hsl.h, hsl.s, hsl.l);
    return `#${color.getHexString()}`;
  }

  function obtenerReaccionesLocales(): Reaccion[] {
    return [
      {
        id: 1,
        nombre: 'S√≠ntesis de Agua',
        descripcion: 'Reacci√≥n de hidr√≥geno con ox√≠geno para formar agua - Reacci√≥n altamente exot√©rmica',
        reactivos: ['H', 'O'],
        productos: ['H‚ÇÇO'],
        formula: '2H‚ÇÇ + O‚ÇÇ ‚Üí 2H‚ÇÇO',
        tipo: 's√≠ntesis',
        peligrosidad: 'alta',
        efectos: {
          colorFinal: '#4A90E2',
          temperatura: 150,
          burbujeo: true,
          humo: true,
          precipitado: false,
          llama: true,
          mensaje: '¬°Agua sintetizada! Reacci√≥n muy exot√©rmica',
          intensidadLuz: 1.0,
          colorLuz: '#FF5500',
          duracion: 8
        }
      },
      {
        id: 2,
        nombre: 'Neutralizaci√≥n √Åcido-Base',
        descripcion: '√Åcido clorh√≠drico reacciona con hidr√≥xido de sodio formando sal com√∫n y agua',
        reactivos: ['HCl', 'NaOH'],
        productos: ['NaCl', 'H‚ÇÇO'],
        formula: 'HCl + NaOH ‚Üí NaCl + H‚ÇÇO',
        tipo: 'doble_sustituci√≥n',
        peligrosidad: 'media',
        efectos: {
          colorFinal: '#ECF0F1',
          temperatura: 45,
          burbujeo: true,
          humo: false,
          precipitado: false,
          llama: false,
          mensaje: 'Sal com√∫n formada - Neutralizaci√≥n completa',
          intensidadLuz: 0.4,
          colorLuz: '#FFFFFF',
          duracion: 6
        }
      },
      {
        id: 3,
        nombre: 'Combusti√≥n de Metano',
        descripcion: 'El metano reacciona con ox√≠geno produciendo di√≥xido de carbono y agua',
        reactivos: ['CH‚ÇÑ', 'O'],
        productos: ['CO‚ÇÇ', 'H‚ÇÇO'],
        formula: 'CH‚ÇÑ + 2O‚ÇÇ ‚Üí CO‚ÇÇ + 2H‚ÇÇO',
        tipo: 'combusti√≥n',
        peligrosidad: 'alta',
        efectos: {
          colorFinal: '#1a1a1a',
          temperatura: 200,
          burbujeo: false,
          humo: true,
          precipitado: false,
          llama: true,
          mensaje: '¬°Combusti√≥n! Liberaci√≥n de energ√≠a t√©rmica',
          intensidadLuz: 1.2,
          colorLuz: '#FF3300',
          duracion: 10
        }
      }
    ];
  }

  // ============================================
  // RETORNO DEL HOOK MEJORADO
  // ============================================

  return {
    // Estado principal
    estado,
    efectosActivos,
    reaccionEnProgreso,
    
    // Gesti√≥n de objetos
    agregarUtensilio,
    agregarElementoAUtensilio,
    moverObjeto,
    eliminarObjeto,
    
    // Gesti√≥n de reacciones
    detectarReaccion,
    iniciarReaccion,
    
    // Control de simulaci√≥n
    iniciarSimulacion,
    detenerSimulacion,
    limpiarMesa,
    reiniciarExperimento,
    
    // Utilidades
    tieneElementos: estado.objetosEnMesa.length > 0,
    tieneReacciones: (estado.historialReacciones?.length || 0) > 0,
    estaActiva: estado.activa
  };
};